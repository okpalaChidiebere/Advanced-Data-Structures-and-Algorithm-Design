#include "tree.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Tree default constructor
//
// purpose: create a tree with an empty root node
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Tree::Tree(){
	root = NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Tree insert private function
//
// purpose: called by destroy_tree public function, traverses through tree and clear
//			it
//
// input: current node to be destroyed
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Tree::destroy_tree(node *leaf)
{
  if(leaf!=NULL)
  {
    destroy_tree(leaf->left);
    destroy_tree(leaf->right);
    delete leaf;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Tree insert private function
//
// purpose: called by insert public function, traverses through tree using
// recursion to find the appropriate spot for value and insert it
//
// input: key value (int), current tree node
// output: depth of inserted value
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Tree::insert(int key, node *leaf)
{
	if(key< leaf->value)  
	{
		if(leaf->left!=NULL)     // check left side of tree comparing values
		return insert(key, leaf->left) + 1; // increment depth counter
		else
		{
			leaf->left=new node;
			leaf->left->value=key;
			leaf->left->left=NULL;
			leaf->left->right=NULL;
			return 1;
		}  
	}
	else if(key>=leaf->value)
	{
		if(leaf->right!=NULL)    // check right side of tree comparing values
		return insert(key, leaf->right) + 1; // increment depth counter
		else
		{
			leaf->right=new node;
			leaf->right->value=key;
			leaf->right->left=NULL;
			leaf->right->right=NULL; 
			return 1;
		}
	}
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Tree insert public function
//
// purpose: initial insert call, checks if tree is empty, and if not, it calls
// the recursive private insert function
//
// input: key value (int)
// output: depth of inserted value (int)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Tree::insert(int key)
{
	if(root!=NULL)         // if tree is not empty, call recursive function and return depth
	return insert(key, root);
	else
	{           // else insert the value at root
		root=new node;
		root->value=key;
		root->left=NULL;
		root->right=NULL;
		return 0; // return depth of 0
	}
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// destroy_tree public function
//
// purpose: initial destroy_tree call, calls destroy_tree private function
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Tree::destroy_tree()
{
  destroy_tree(root);
}